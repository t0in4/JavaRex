Регулярные выражения Java

В Java регулярные выражения используются, как и в других языках программирования для решения определенных проблем:
подтверждение: определить, соответствует ли строка образцу, дав булевый ответ да/нет
извлечение: извлечь часть(части) строки соответствующие образцу
заменить: заменить часть(части) строки соответствующие образцу в заменяемой строке
расщепить (разделить): удалить части которые соответствуют образцу, в результате получаем массив строк

В Java все регулярные выражения используются как строки, что означает, что спец символы(.,!?+ и т.д.) должные исключаться (\). Например, так выглядит
обычное регулярное выражение \w+, в строке:
"\\w+"

Строчные операции.
Большинство простых операций подтверждения и замены с помощью регулярных выражений, может быть достигнуто с помощью методов класса String.
Метод строки matches используется следующим образом:
if ( sample.matches( pattern_string ) ) {
  // sample does match the pattern
}
Строка pattern_string считается полной в том смысле, что вся строка должна совпадать с шаблоном.
В частности, не надо использовать узловые точки ^ - начала строки и $ - конца строки в шаблоне, чтобы разграничить шаблон, как в ситуациях, когда не используется метод matches.
В Java есть методы класса String, которые начинаются с префикса 'replace'; 
Однако, только эти два (replaceFirst, replaceAll) полагаются на регулярные выражения, чтобы определить
заменяемую подстроку.
В отличии от - matches, эти операции позволяют искать подстроки в строке.

String new_string = sample.replaceFirst( pattern_string, replacement );
String new_string = sample.replaceAll( pattern_string, replacement );

Ограничения этой схемы замены в том, что она не может сгенерировать заменяющую строку основываясь
на совпадающем содержании. Например, мы не можем использовать replaceAll чтобы выполнить следующие
операции:
- окружить каждое совпадение "[a-z]+\d+" разделителями, например, такими как "<" и ">"
- сделать каждое совпадение подстроки "[a-z]+\d+" с заглавной буквы

Для более сложных операций сопоставления/замены, Java использует классы Pattern и Matcher из пэкэджа
java.util.regex. Альтернативный путь выражения подтверждения с помощью регулярных выражений, через
использование метода:
Pattern.matches(pattern_string, sample);
чьё поведение в точности совпадает с выражением использованным выше - "sample.matches(pattern_string)"
Более сложные регулярные выражения используют следующие утверждение:
Pattern pattern = Pattern.compile(pattern_string);
Matcher matcher = pattern.matcher(sample);
Операция Pattern.compile может использовать второй аргумент для определения других характеристик операции
поиска совпадений. Наиболее часто используется для удостоверения, что все совпадения не зависят от регистра 
букв:
Pattern pattern = Pattern.compile(pattern_string, Pattern.CASE_INSENSITIVE);

Операция поиска соответсвия инициализируется вызовом:
matcher.find())
Одно из полезных свойств matcher.find() которое важно для нашего следующего примера, это возможность
произвести позицию строки которая разделяет совпадающую подстроку используя этот метод:
int start = matcher.start();
int end = matcher.end();

Выражение matcher.group() выводит вся совпающую подстроку, в то время, как matcher.start() (включительно)
и matcher.end() (не включительно) раскрывает разделяюцие индексы внутри всей строки.

Совпадения подстроки
Во многих обстоятельствах, мы заинтересованы в подшаблоне шаблона совпадения. Например, 
рассмотрим шаблон и тестовую строку:
String pattern_string = "([a-z]+)(\\d+)";
String sample = "Ab c55 24 Hello3 a.2 8a bbb00";
pattern = Pattern.compile(patternStr);
matcher = pattern.matcher(testStr);
В этом случае, наш шаблон использует круглые скобки, которые разделяют последовательность букв
от последовательности цифр. Мы можем идентифицировать подстроки, которые совпадают с подшаблоном в
круглых скобках.

matcher.group(i) это подстрока совпадающая с подшаблоном определенным в паре скобок по индексу внутри общего шаблона.

Замена
Замена совпадающего образца использует методы класса String - replaceFirst и replaceAll. Эффект
в основном такой же, как с исключением того, что вы можете использовать совпадающие части внутри
аргументов замены.
Внутри шаблона для поиска замены, мы можем использовать специальные переменные $0, $1, $2 со
следующими значениями:
$0 = вся совпадающая подстрока
(соотносится с matcher.group())
$1 = первая подстрока в круглых скобках
(соотносится с matcher.group(1))
$2 = вторая подстрока в круглых скобках
(соотносится с matcher.group(2)) и т.д.
